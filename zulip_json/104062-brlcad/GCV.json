[
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span> <a href=\"#narrow/stream/104062-general/topic/superbuild/near/217799890\">said</a>:</p>\n<blockquote>\n<p>yeah, sorry for the ping <span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> -- that's not something you need to read through.  Summary is just that gcv needs some lovin' and your work making a plugin for it make that obvious.</p>\n</blockquote>\n<p>So i was busy with my studies and a personal project.......is there anything i can do to help fix GCV?</p>",
        "id": 219511244,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1607623752
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247135\">@Sumagna Das</span> woo hoo!  so how'd your testing go?  hopefully passed all your exams :)</p>",
        "id": 219528406,
        "sender_full_name": "Sean",
        "timestamp": 1607631598
    },
    {
        "content": "<p>Yup...the exams went well..</p>",
        "id": 219528485,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1607631627
    },
    {
        "content": "<p>awesome</p>",
        "id": 219528498,
        "sender_full_name": "Sean",
        "timestamp": 1607631634
    },
    {
        "content": "<p>that's always a good feeling to have that behind you.</p>",
        "id": 219528524,
        "sender_full_name": "Sean",
        "timestamp": 1607631643
    },
    {
        "content": "<p>As for GCV, I think the main stopper is how mime types are implemented by gcv and bu.  If you recall, it was having trouble forwarding your PNG input file to your plugin.</p>",
        "id": 219528834,
        "sender_full_name": "Sean",
        "timestamp": 1607631777
    },
    {
        "content": "<p>couple issues there, I think</p>",
        "id": 219528869,
        "sender_full_name": "Sean",
        "timestamp": 1607631795
    },
    {
        "content": "<p>yea......it wasnt recognizing PNG files.</p>",
        "id": 219528884,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1607631805
    },
    {
        "content": "<p>right, that's because PNGs are a 2D type and GCV is expecting 3D types because that's how LIBBU was implemented, separating them into groups</p>",
        "id": 219528990,
        "sender_full_name": "Sean",
        "timestamp": 1607631846
    },
    {
        "content": "<p>ohh.......thats why it was taking the PNG file as <code>GCV_MODEL_UNKNOWN</code> Or something like that</p>",
        "id": 219529085,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1607631901
    },
    {
        "content": "<p>you can find that nutty logic in src/libbu/mime.cmake where it autogenerates source code.  you can see the source code it generated by looking in the build dir at src/libbu/mime.c</p>",
        "id": 219529105,
        "sender_full_name": "Sean",
        "timestamp": 1607631916
    },
    {
        "content": "<p>bingo, correct</p>",
        "id": 219529116,
        "sender_full_name": "Sean",
        "timestamp": 1607631923
    },
    {
        "content": "<p>we had to say \"handle anything\" because it's a type in a completely different mime type bucket</p>",
        "id": 219529156,
        "sender_full_name": "Sean",
        "timestamp": 1607631942
    },
    {
        "content": "<p>so I think we need to change that in libbu</p>",
        "id": 219529169,
        "sender_full_name": "Sean",
        "timestamp": 1607631952
    },
    {
        "content": "<p>i will look into <code>mime.cmake</code> tomorrow</p>",
        "id": 219529257,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1607631983
    },
    {
        "content": "<p>to either flatten the mime typing like it is in the original data file (see misc/mime.types) with the groupings being optional tagging</p>",
        "id": 219529306,
        "sender_full_name": "Sean",
        "timestamp": 1607632010
    },
    {
        "content": "<p>actually, that's the best approach I can come up with besides just recreating a mime typing API again (from scratch or otherwise)</p>",
        "id": 219529536,
        "sender_full_name": "Sean",
        "timestamp": 1607632128
    },
    {
        "content": "<p>probably easier than looking at mime.cmake is to simply look at include/bu/mime.h with a critical eye towards what needs to change</p>",
        "id": 219529720,
        "sender_full_name": "Sean",
        "timestamp": 1607632211
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/219529306\">said</a>:</p>\n<blockquote>\n<p>to either flatten the mime typing like it is in the original data file (see misc/mime.types) with the groupings being optional tagging</p>\n</blockquote>\n<p>what do you mean by <em>flatten</em>?</p>",
        "id": 219529767,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1607632233
    },
    {
        "content": "<p>the issue is the bu_mime_context_t parameters -- those have apps pick between 2d, 3d, video, and other mime type sets</p>",
        "id": 219529807,
        "sender_full_name": "Sean",
        "timestamp": 1607632255
    },
    {
        "content": "<p>they could all be combined into one, for example, thus grouping them into one context (for example)</p>",
        "id": 219529885,
        "sender_full_name": "Sean",
        "timestamp": 1607632291
    },
    {
        "content": "<p>that's what was meant by flattening them -- grouping into one set</p>",
        "id": 219530123,
        "sender_full_name": "Sean",
        "timestamp": 1607632384
    },
    {
        "content": "<p>or making null  or a default be all sets or something</p>",
        "id": 219530670,
        "sender_full_name": "Sean",
        "timestamp": 1607632663
    },
    {
        "content": "<p>i just saw the files you told me to see....</p>",
        "id": 220161749,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608147157
    },
    {
        "content": "<p>what am i supposed to do here?</p>",
        "id": 220161793,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608147181
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247135\">@Sumagna Das</span> what's your perspective on the mime.h api?  we either need to add/create a mime group that has all types (in addition to or instead of the domain-specific groups), or we could remove the groupings so it's just a type-based lookup like the system mime-type system.</p>",
        "id": 220286675,
        "sender_full_name": "Sean",
        "timestamp": 1608231662
    },
    {
        "content": "<p>Or something else entirely.  It's a design decision that has to be made next.  From there, the coding changes are pretty straightforward.</p>",
        "id": 220286721,
        "sender_full_name": "Sean",
        "timestamp": 1608231695
    },
    {
        "content": "<p>maybe think about how you would have WANTED to write the code in gcv, in an ideal world.</p>",
        "id": 220286808,
        "sender_full_name": "Sean",
        "timestamp": 1608231730
    },
    {
        "content": "<p>we can remove the groupings..</p>",
        "id": 220290842,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608233619
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 220615777,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608576278
    },
    {
        "content": "<p>hey <span class=\"user-mention\" data-user-id=\"102902\">@Sean</span>, will any of the files in the rest of the codebase be affected if we remove the groupings?</p>",
        "id": 220615869,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608576334
    },
    {
        "content": "<p>and one other thing........is there any named type called <code>bu_mime_context</code>?</p>",
        "id": 220625575,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608581695
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"102902\">@Sean</span>  I offer this merely as food for thought - conceptually, could we think about \"conversions\" between different mime type categories (i.e. images and geometry files) not as conversions but as procedural geometry generations?  That would categorize the task of generating some kind of geometry file from a PNG image as a task for a different type of program...</p>",
        "id": 220646128,
        "sender_full_name": "starseeker",
        "timestamp": 1608596149
    },
    {
        "content": "<p>That appeals to me in some ways since it would mean the conceptually ambiguity (i.e. should a PNG import become a binary object in a .g file, a shader texture, a terrain DSP object, etc...) would then be out of scope for GCV.</p>",
        "id": 220646265,
        "sender_full_name": "starseeker",
        "timestamp": 1608596263
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"102902\">@Sean</span> i dont know if i were supposed to do this before telling anything but i removed the <code>bu_mime_image_t</code>-kinda grouping and combined them into <code>bu_mime_context_t</code> group. I renamed the group containing <code>BU_MIME_APPLICATION</code>, <code>BU_MIME_IMAGE</code>, etc from <code>bu_mime_context_t</code> to <code>bu_mime_context</code>.</p>",
        "id": 220729802,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608668128
    },
    {
        "content": "<p>/me is bad at naming variables.</p>",
        "id": 220729904,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608668185
    },
    {
        "content": "<p>imma send the <code>mime_types.h</code> and <code>mime.cmake</code> so that you can see what i did (other than doing the other naming changes)</p>",
        "id": 220730441,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608668608
    },
    {
        "content": "<p><a href=\"/user_uploads/1549/LgALZjf0Kn3yIDlR7rON_2ym/mime.cmake\">mime.cmake</a><br>\n<a href=\"/user_uploads/1549/lKyJeVEIofC14d-yknxjFVlS/mime_types.h\">mime_types.h</a></p>",
        "id": 220730585,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608668717
    },
    {
        "content": "<p>these are the two main files that have been changed (i know that <code>mime.cmake</code> changes the second file but it was one of the major changes i did)</p>",
        "id": 220730674,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608668777
    },
    {
        "content": "<p>i fixed GCV not taking any mime type other than <code>BU_MIME_MODEL_UNKNOWN</code></p>",
        "id": 220816281,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608749204
    },
    {
        "content": "<p>the <code>((bu_mime_context_t)type_int) != BU_MIME_MODEL_UNKNOWN</code> condition in <code>fmt_type()</code> function in <code>gcv.c</code> was causing the problem...i changed it to <code>((bu_mime_context_t)type_int) != BU_MIME_MODEL_UNKNOWN &amp;&amp; type_int != -1</code></p>",
        "id": 220816899,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608749593
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"102902\">@Sean</span>  PS: if you didnt see the <code>mime.cmake</code> file, then i want to notify you that i flattened the groupings and because of that,  every group like <code>bu_mime_model_t</code> is combined into <code>bu_mime_context_t</code></p>",
        "id": 220817440,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1608750009
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/220646265\">said</a>:</p>\n<blockquote>\n<p>That appeals to me in some ways since it would mean the conceptually ambiguity (i.e. should a PNG import become a binary object in a .g file, a shader texture, a terrain DSP object, etc...) would then be out of scope for GCV.</p>\n</blockquote>\n<p>Hm, interesting though but I think it'd be fairly arbitrary and (more importantly) not user friendly.  Don't think it's a distinction that fits our modeling paradigm as implicit geometry means object data is often in some lower-dimensional form.  Your gdal linkage is a good example.  Perfectly normal for terrain data to live in 2D tiff/png/jpg container, and as such I'd entirely expect gcv to handle converting it.  Same for vol data.  The data lives in 2D containers, and I would expect gcv to handle them just the same.  Pulling out terrain, vol, ebm, pnts, and even BoT creation (e.g., when container is say a txt file with xyz, for example) wouldn't be terribly obvious to me. </p>\n<p>I think gcv's on the right track already.  The mime type issue is just an issue because the current BU interface is attempting to categorize and the categories are obviously restricting visibility.  They're a namespace.  We just need to complete the metaphor by introducing global namespacing (i.e., uncategorized), and this should be solved.</p>",
        "id": 220971168,
        "sender_full_name": "Sean",
        "timestamp": 1609002078
    },
    {
        "content": "<p>I kind of see this getting inverted.  We have a master list of types (mime.types) that are string-&gt;type mappings.  We have a series of additional types that are akin to \"image/* -&gt; png, tiff, jpg, gif, ...\" mappings so callers can distinguish on any type or rich subsets of types (or exclude types).</p>",
        "id": 220971291,
        "sender_full_name": "Sean",
        "timestamp": 1609002263
    },
    {
        "content": "<p>Towards that, we may want to make those explicit in our mime.types file so any grouping types are auto-generated instead of encoded.</p>",
        "id": 220971326,
        "sender_full_name": "Sean",
        "timestamp": 1609002356
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/220730441\">said</a>:</p>\n<blockquote>\n<p>imma send the <code>mime_types.h</code> and <code>mime.cmake</code> so that you can see what i did (other than doing the other naming changes)</p>\n</blockquote>\n<p>Can you send an svn diff too?  Not easy to see what all was changed in mime.cmake, how it compares.</p>",
        "id": 220971517,
        "sender_full_name": "Sean",
        "timestamp": 1609002659
    },
    {
        "content": "<p>I'm increasingly thinking we want a traditional string mapping, so apps/callers can do globbing or lookups on their own (e.g., mime.lookup(\"/path/to/myfile\") or mime.lookup(\".jpg\"))</p>",
        "id": 220971644,
        "sender_full_name": "Sean",
        "timestamp": 1609002954
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/220971517\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/220730441\">said</a>:</p>\n<blockquote>\n<p>imma send the <code>mime_types.h</code> and <code>mime.cmake</code> so that you can see what i did (other than doing the other naming changes)</p>\n</blockquote>\n<p>Can you send an svn diff too?  Not easy to see what all was changed in mime.cmake, how it compares.</p>\n</blockquote>\n<p>only for mime.cmake?</p>",
        "id": 220972911,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1609005159
    },
    {
        "content": "<p><a href=\"/user_uploads/1549/N8gW_jcR8gNbo8t81kQYGXo2/changes.diff\">changes.diff</a></p>",
        "id": 220973095,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1609005560
    },
    {
        "content": "<p>it might be a little dirty because i wasnt sure about the changes i was making.....if it needs cleaning up, then tell me where it needs <br>\na little cleanup..</p>",
        "id": 220973270,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1609005822
    },
    {
        "content": "<p>I'm not entirely sure I follow - you mean we'd define image/png and terrain/png as distinct mime types, and given a png file the user would need to identify the mime type explicitly so the converter would know what to do with it?</p>",
        "id": 220981246,
        "sender_full_name": "starseeker",
        "timestamp": 1609020685
    },
    {
        "content": "<p>no, not inventing types like that.  I meant making the categoric groupings like image/* be an enum type in the same namespace.  So like how BU_MIME_IMAGE_JPEG is supposed to match \"jpg\" or \"jpeg\" etc, there'd also be a BU_MIME_IMAGE that'd represent all the BU_MIME_IMAGE_* types instead of having a separate context data structure.  There'd just be a master registry like sumagna has now with additional groupings like we had before so plugins can just ask for a type, or can narrow in on a subset, or call out a custom set.</p>",
        "id": 220996397,
        "sender_full_name": "Sean",
        "timestamp": 1609050835
    },
    {
        "content": "<p>(Sorry - I'm sure I'm either being dense or missing the point...) </p>\n<p>I'm still not following... when gcv gets the input:</p>\n<p>gcv image.tiff output.g</p>\n<p>how is the question decided as to whether that tiff image ends up as an ebm, a terrain object, a shader object, or just a straight up binary object holding the image?  All of those are potentially valid interpretations of the same data...</p>",
        "id": 221040591,
        "sender_full_name": "starseeker",
        "timestamp": 1609134117
    },
    {
        "content": "<p>The only way I can see is the user must provide somehow additional context that specifies one of those outcomes, but I'm not seeing a good way yet to do it...</p>",
        "id": 221040640,
        "sender_full_name": "starseeker",
        "timestamp": 1609134170
    },
    {
        "content": "<p>SO what should i do about the changes i made in the files for flattening the mime types alongside keeping the group names only?</p>",
        "id": 221363301,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1609526539
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/221363301\">said</a>:</p>\n<blockquote>\n<p>SO what should i do about the changes i made in the files for flattening the mime types alongside keeping the group names only?</p>\n</blockquote>\n<p>hey <span class=\"user-mention\" data-user-id=\"102902\">@Sean</span>  what should i do about these changes?</p>",
        "id": 225009881,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1612356529
    },
    {
        "content": "<p>Did we ever come to a conclusion on this?  I'm really not happy about flattening the image vs. geometry context out of the mime types unless/until we have another way to distinguish those categories...</p>\n<p>Looking at the icv/io.h changes in the pull request, bu_mime_context_t just feels too generic to me - personally, I want things to fail immediately and hard at build time if I accidentally  try to feed a geometry file type through an image conversion...</p>",
        "id": 231832124,
        "sender_full_name": "starseeker",
        "timestamp": 1616689465
    },
    {
        "content": "<p>I still don't have any good feeling for what gcv is supposed to do when the input \"gcv image.png image.g\" is given to it...</p>",
        "id": 231832434,
        "sender_full_name": "starseeker",
        "timestamp": 1616689595
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/231832124\">said</a>:</p>\n<blockquote>\n<p>Did we ever come to a conclusion on this?  I'm really not happy about flattening the image vs. geometry context out of the mime types unless/until we have another way to distinguish those categories...</p>\n<p>Looking at the icv/io.h changes in the pull request, bu_mime_context_t just feels too generic to me - personally, I want things to fail immediately and hard at build time if I accidentally  try to feed a geometry file type through an image conversion...</p>\n</blockquote>\n<p>oh.......didnt knew you wouldnt agree with that.</p>",
        "id": 231853024,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1616697054
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247135\">@Sumagna Das</span> I'll defer to <span class=\"user-mention\" data-user-id=\"102902\">@Sean</span>  - he has a clearer vision than I do of where he wants to go with GCV.  I'm just fundamentally bothered by my inability to answer the question \"What is supposed to happen when the user gives us 'gcv image.png output.g' on the command line.\"</p>",
        "id": 231853340,
        "sender_full_name": "starseeker",
        "timestamp": 1616697178
    },
    {
        "content": "<p>The options I know of for \"gcv image.png output.g\" are:</p>\n<ol>\n<li>\n<p>Just error out with some sort of inadequate specification error unless something like a specific backend is supplied - i.e., require something like \"gcv image.png --plugin GDAL output.g\" before proceeding.  Works, but has negative usability implications.</p>\n</li>\n<li>\n<p>Always default to the \"highest order\" output - i.e. for a PNG file, we can default to a height field geometric interpretion and require specification for something else like a texture/shader object or binary object.  Easiest from the user perspective IF what we default to is what they want, but potentially frustrating if it does the \"wrong\" thing for their particular case and they don't know what to do to change the behavior.</p>\n</li>\n<li>\n<p>Just define any non geometry-&gt;geometry conversions as out of scope for gcv - i.e. turning cases involving image data that can't be unambiguously identified as terrain data over to procedural geometry generators rather than the gcv converter.   This has the virtue of simplicity, since anything that doesn't have an unambiguous geometric interpretation is simply an invalid input to gcv and another tool is required.  However, in prior discussions Sean felt that failing to convert in such cases would be a usability hit.</p>\n</li>\n</ol>",
        "id": 231855610,
        "sender_full_name": "starseeker",
        "timestamp": 1616698049
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/231832124\">said</a>:</p>\n<blockquote>\n<p>Did we ever come to a conclusion on this?  I'm really not happy about flattening the image vs. geometry context out of the mime types unless/until we have another way to distinguish those categories...</p>\n<p>Looking at the icv/io.h changes in the pull request, bu_mime_context_t just feels too generic to me - personally, I want things to fail immediately and hard at build time if I accidentally  try to feed a geometry file type through an image conversion...</p>\n</blockquote>\n<p>i was also checking the changes for the removing the 2nd level groupings and it does seem like that removing them could pose a problem.</p>",
        "id": 231858710,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1616699177
    },
    {
        "content": "<p>if a specific category is not specified, then there is actually a program that some program using these types can be fed anything as input rather than getting files from a specific category. for example, like you said, ICV is supposed to get only images as input but removing the 2nd level grouping can mean that it can get any type of file as input</p>",
        "id": 231859063,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1616699317
    },
    {
        "content": "<p>one thing i did in one of the commits is that alongside keeping the 2nd level grouping is that i added a <code>BU_MIME_AUTO</code> which acted like a switch saying that search from the whole of the mime types' namespace.</p>",
        "id": 231859315,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1616699436
    },
    {
        "content": "<p>that enum can work pretty well for now for GCV so that it gets all the types of files</p>",
        "id": 231859410,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1616699496
    },
    {
        "content": "<p>but as you said for the 2nd option, the plugin will not know what the user wants and do a default conversion</p>",
        "id": 231859773,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1616699643
    },
    {
        "content": "<p>A lot of excellent insights mentioned, but we shouldn't lose sight of the implementation goal at hand -- namely, creating a vol from a stack of one or more images and how that usability and discovery plays out.  The existing BU interface can't/couldn't handle it, so changes are needed.  That's not to say that we can also have groupings, or that we don't still also have to sort out what a given conversion request behavior should be, too.</p>",
        "id": 231878217,
        "sender_full_name": "Sean",
        "timestamp": 1616707364
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112516\">@starseeker</span> I think your summary of \"gcv image.png output.g\" options are spot-on.  I would flat-out reject #3 as unreasonable and unnecessary restriction.  The problem of there being multiple conversion results possible for a given input is not unique to images by any stretch.   Geometry have that problem as well.</p>",
        "id": 231878591,
        "sender_full_name": "Sean",
        "timestamp": 1616707524
    },
    {
        "content": "<p>I think the gdal integration is further supporting evidence -- it makes complete usability sense to me that the conversion tool will accept a 2d input and have the wherewithall to generate a 3d representation from it.</p>",
        "id": 231878764,
        "sender_full_name": "Sean",
        "timestamp": 1616707590
    },
    {
        "content": "<p>As for options #1 and #2, they're not mutually exclusive and I think we'll end up wanting to do a mix of both.  They're certainly related to the typing system and ability to do something high-order automatically, but not strictly coupled to it (beyond our existing implementation coupling them).</p>",
        "id": 231878986,
        "sender_full_name": "Sean",
        "timestamp": 1616707700
    },
    {
        "content": "<p>So then what's our way forward to arrive at a concrete implementation design?</p>",
        "id": 231879563,
        "sender_full_name": "starseeker",
        "timestamp": 1616707962
    },
    {
        "content": "<p>That's where I keep getting stuck... if we want to allow the complexity explosion of N conceptual interpretations of what it means to convert image data to geometry data, how do we encapsulate that in a usable way for programmer and user?  Every attempt I've made has fallen short...</p>",
        "id": 231880007,
        "sender_full_name": "starseeker",
        "timestamp": 1616708132
    },
    {
        "content": "<p>Actually I wouldn't have said the first attempt fell short, it just made an assumption that didn't hold up to the next plugin.  So we know some adaptation is needed.</p>",
        "id": 231880377,
        "sender_full_name": "Sean",
        "timestamp": 1616708290
    },
    {
        "content": "<p>Without punting the adaptation to the user yet, there are two issues.  First there is/was no way for a plugin to declare that it handles a non-geometric type.  Second, there didn't appear to be a way to route to the plugin manually (had to manually disable other plugins).</p>",
        "id": 231880683,
        "sender_full_name": "Sean",
        "timestamp": 1616708451
    },
    {
        "content": "<p>I think the original plan for gcv plugins is still the way to go -- namely that plugins define the processing architecture by declaring what they can handle and reporting whether they can handle a particular input.</p>",
        "id": 231880861,
        "sender_full_name": "Sean",
        "timestamp": 1616708530
    },
    {
        "content": "<p>With #1 fixed by doing \"some change\" to the typing system -- there is a decision we have to immediately face, namely what to do when two plugins support the type and two plugins say yes to handling that particular input.  A PNG input is nominally something we can handle today in three ways (gdal, this new vol plugin, and binary/image object).</p>",
        "id": 231881170,
        "sender_full_name": "Sean",
        "timestamp": 1616708690
    },
    {
        "content": "<p>There's another issue as well - if we're allowing multiple interpretations (terrain, shader, extrusion, binary blob, etc.) then the mime specification isn't going to be sufficient for the plugin API identification on its own.  We need some way for a plugin to say \"I support image-&gt;terrain, image-&gt;blob, but not image-&gt;shader\" (for example.)</p>",
        "id": 231881251,
        "sender_full_name": "starseeker",
        "timestamp": 1616708730
    },
    {
        "content": "<p>That's for filter plugins.  There can be many plugins, but a given plugin is going to do one of those.  We can probably constrain it to only being one of those from a declaration standpoint, or let the input callback make more complex or specific determinations.</p>",
        "id": 231881969,
        "sender_full_name": "Sean",
        "timestamp": 1616709075
    },
    {
        "content": "<p>In the original architecture concept, filters did not deal with typed input at all.  We could reduce them down to that and it would probably greatly simplify processing (and plugin implementation).</p>",
        "id": 231882203,
        "sender_full_name": "Sean",
        "timestamp": 1616709189
    },
    {
        "content": "<p>Actually, I semi-lost site of the original prompting issue for the question - in the proposed github pull request, the icv API is changed so that it too takes a generic mime type, rather than just image mime types.  For your design vision, is that an OK direction?</p>",
        "id": 231882619,
        "sender_full_name": "starseeker",
        "timestamp": 1616709400
    },
    {
        "content": "<p>That's a good question.  I'd not looked into the pull request in detail yet, but the gist I think is not unreasonable.  And for similar reasons, say one wanted to implement a plugin that created an image from a .txt file that contained r g b d data, or from an .xls file where some range of cells has rgb values, etc.</p>",
        "id": 231882970,
        "sender_full_name": "Sean",
        "timestamp": 1616709611
    },
    {
        "content": "<p>I think all that's needed to let that work is for a plugin to be able to list it's types.  Any nuance  can be handled in the callback.  To make it convenient, we can provide meta types (e.g., BU_MIME_IMAGE, BU_MIME_MODEL, etc.).</p>",
        "id": 231883770,
        "sender_full_name": "Sean",
        "timestamp": 1616710009
    },
    {
        "content": "<p>That would preserve the two-level namespace as data.</p>",
        "id": 231883910,
        "sender_full_name": "Sean",
        "timestamp": 1616710087
    },
    {
        "content": "<p>The outstanding questions for bu_mime are 1) do we need to make multiple typedefs available, i.e., what code or feature(s) will benefit from a compile-time type restriction and 2) do we want/need defines for meta groupings and 3) do we want/need string-based type associations (whether as a grouping mechanism, for interfacing with other things, or ...?)</p>",
        "id": 231886031,
        "sender_full_name": "Sean",
        "timestamp": 1616711216
    },
    {
        "content": "<p>i understood most of the part here until the last 4 or 5 messages <span aria-label=\"sweat smile\" class=\"emoji emoji-1f605\" role=\"img\" title=\"sweat smile\">:sweat_smile:</span></p>",
        "id": 231909895,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1616729479
    },
    {
        "content": "<p>LOL <span class=\"user-mention\" data-user-id=\"247135\">@Sumagna Das</span></p>",
        "id": 231998100,
        "sender_full_name": "Sean",
        "timestamp": 1616777556
    },
    {
        "content": "<p>basically, trying to figure out what/how exactly should bu_mime change so that we can still hard-fail during compilation on a categoric type (if that is needed somewhere) but also support plugins declaring their support and being potentially more nuanced in their input validation callback.</p>",
        "id": 231998581,
        "sender_full_name": "Sean",
        "timestamp": 1616777724
    },
    {
        "content": "<p>I think @starseeker is probably not (yet)fond of the idea of some tools like icv handling non-image formats (e.g., data files), and that's a valid critique.  I see it essentially required and thus will require a bit more thought on how tools like icv/gcv respond when there are 2+ plugins that say they can handle a given input.</p>\n<p>For example, we likely will have 3 plugins that read a png file in gcv and they're all roughly equal probability:  png-to-dsp-via-gdal, png-to-vol, png-to-binunif</p>",
        "id": 231999599,
        "sender_full_name": "Sean",
        "timestamp": 1616778107
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/231999599\">said</a>:</p>\n<blockquote>\n<p>I think @starseeker is probably not (yet)fond of the idea of some tools like icv handling non-image formats (e.g., data files), and that's a valid critique.  I see it essentially required and thus will require a bit more thought on how tools like icv/gcv respond when there are 2+ plugins that say they can handle a given input.</p>\n<p>For example, we likely will have 3 plugins that read a png file in gcv and they're all roughly equal probability:  png-to-dsp-via-gdal, png-to-vol, png-to-binunif</p>\n</blockquote>\n<p>thats a big problem......</p>",
        "id": 232007916,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1616781491
    },
    {
        "content": "<p>did you guys come to any conclusion? i want to finish this thing before my exams from 12th april.</p>",
        "id": 232323601,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617046663
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247135\">@Sumagna Das</span> I'm not seeing a better way around it.  Options seem to be:<br>\nA) require non-geometric plugins to resort to being an \"unknown\" type whereupon the same problem of routing still exists for all such plugins (which would also require something like forced user-specification which would hurt usability/discoverability).  I think this is architecturally a problem because there's not a more appropriate place for such functionality, yet typing as unknown would kind of imply they're second-class plugins or otherwise unsupported.<br>\nB) let the functionality be handled elsewhere and limit gcv strictly to geometry file inputs.  for example, the vol command could read in from images, the dsp command could read in via gdal.  while that would be useful in workflows, it seems like it doesn't address gcv being an intuitive place to read data files that result in geoemtry.  again, gdal is a great example of this.<br>\nC) make changes to the typing system and gcv so it will route files to plugins that handle that file(s) type.   fairly unobtrusive change imho.  it doesn't answer what happens when multiple plugins handle the same input type but then neither does the current code or options A or B. <br>\nD) eliminate the typing system.  it's not strictly required.  its intent was to improve usability so if there was only one plugin or set of plugins that could handle a given conversion, that it would just do it instead of a user explicitly having to say which plugin (e.g., gcv --i gdal input.png output.g</p>\n<p>There is declarative simplicity with D and in some respects we probably should have started there, but B and C have superior usability in my view, C winning out overall as more discoverable. </p>\n<p>Towards that end, I think what we should do is keep some means to know we have (for example) and image vs geometry vs something else.  I think that can be a sub-typedef like bu_mime_image_t and bu_mime_model_t for compile time restriction or it can be a meta type like BU_MIME_IMAGE for runtime restriction (I don't feel strongly for either being better).  That will be helpful for commands like overlay or screengrab that only deal with images.  As for gcv, I think that'll generalize to something like bu_mime_t (which has all types) and plugins declare a set of one or more mime types.  In the case where multiple plugins match, we'll make it report the conflict, list out available options, and require the user specify.</p>",
        "id": 232374156,
        "sender_full_name": "Sean",
        "timestamp": 1617080185
    },
    {
        "content": "<p>B and D sound more like it to me.</p>",
        "id": 232376266,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617082414
    },
    {
        "content": "<p>but the problem still stays that there will a uncertainty about what happens when multiple plugins handle the same file type</p>",
        "id": 232376406,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617082552
    },
    {
        "content": "<p>we can do B but alongside we can make it report if any conflict exists where multiple plugins are trying to handle the same file.</p>",
        "id": 232376658,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617082818
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247135\">@Sumagna Das</span> they are certainly options, but they have an undeniable impact on usability and discoverability, and which went or at least go against the original design plans for gcv (that it will figure out what's best when/where it can)</p>",
        "id": 232443786,
        "sender_full_name": "Sean",
        "timestamp": 1617117480
    },
    {
        "content": "<p>(deleted)</p>",
        "id": 232487262,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617134140
    },
    {
        "content": "<p>i was trying to find out the real definition of GCV and found out what it was initially made for (Geometry Conversion library) so i think the plugins which handle non-geometry types should be seperated from GCV and either be made into a command inside mged or be  made a fully seperate executable or be added as an option to existing commands inside or outside mged.</p>",
        "id": 232487633,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617134292
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247135\">@Sumagna Das</span> except what constitutes \"non-geometry\" is very much debatable, it depends on the data format, and depends on the data domain (where it came from).</p>",
        "id": 232514081,
        "sender_full_name": "Sean",
        "timestamp": 1617147374
    },
    {
        "content": "<p>for example, is a text file full of XYZ vertices a geometry type?</p>",
        "id": 232514140,
        "sender_full_name": "Sean",
        "timestamp": 1617147431
    },
    {
        "content": "<p>because that's a common \"geometry\" format that could be a polygonal mesh (it's called xyz format) or it could be point cloud scan data (is that geometry??) or it could be raw terrain elevation data (certainly represents geometry) ...</p>",
        "id": 232515669,
        "sender_full_name": "Sean",
        "timestamp": 1617148531
    },
    {
        "content": "<p>and yet that same can be said of an image files too -- they're just a quantized array of data.  could be terrain (PNG <em>is</em> a standard format for terrain data) ... or could just be an image.</p>",
        "id": 232515800,
        "sender_full_name": "Sean",
        "timestamp": 1617148607
    },
    {
        "content": "<p>in the medical industry, dicom is their geometry file format, but they are just sets of images.  they can represent 3D volumes or point clouds ... or just be images with no 3D implication.</p>",
        "id": 232515937,
        "sender_full_name": "Sean",
        "timestamp": 1617148698
    },
    {
        "content": "<p>gcv's original scope was the consolidation of a bunch of geometry converters into one tool, but even from the onset that already included data files too, so I don't think it's a out of place to include them.  moreover, and more problematically, it doesn't solve a problem by excluding them -- if anything it would create pointless work like extracting gdal from gcv.</p>",
        "id": 232516271,
        "sender_full_name": "Sean",
        "timestamp": 1617148889
    },
    {
        "content": "<p>didnt know geometry types were this complicated</p>",
        "id": 232526177,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617157011
    },
    {
        "content": "<p>The waters are muddy and we're learning, will make mistakes.  I think it's all good.  We can try a direction and if it doesn't work out, we can change it.  I think the least code churn at this point is to just tweak bu_mime to provide a means to scan all types and let plugins declare whatever it is they read/write.  We'll learn.</p>",
        "id": 232579647,
        "sender_full_name": "Sean",
        "timestamp": 1617192989
    },
    {
        "content": "<p>I had that part ready so that it could scan from all types</p>",
        "id": 232614893,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617205712
    },
    {
        "content": "<p>But It would need the 2nd level grouping which I removed</p>",
        "id": 232614959,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617205737
    },
    {
        "content": "<p>Also<br>\nIs it needed tobring back <code>bu_mime_*_t</code> enums or should they be combined like they are right now?</p>",
        "id": 232615104,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617205795
    },
    {
        "content": "<p>I think we should keep both typedefs for now.  That way commands like screengrab can literally be hard-limited to image formats.</p>",
        "id": 232649055,
        "sender_full_name": "Sean",
        "timestamp": 1617218330
    },
    {
        "content": "<p>but then also have a bu_mime_t that has them all</p>",
        "id": 232649093,
        "sender_full_name": "Sean",
        "timestamp": 1617218345
    },
    {
        "content": "<p>(instead of bu_mime_context_t, not really a benefit introducing another term)</p>",
        "id": 232649165,
        "sender_full_name": "Sean",
        "timestamp": 1617218377
    },
    {
        "content": "<p>can you check the PR</p>",
        "id": 232649359,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617218441
    },
    {
        "content": "<p>i removed the commit which remove the 2nd level grouping like BU_MIME_IMAGE, etc</p>",
        "id": 232649418,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617218463
    },
    {
        "content": "<p>i also added BU_MIME_AUTO which searches from all of them</p>",
        "id": 232649486,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1617218483
    },
    {
        "content": "<p>sorry for the inactivity<br>\ni had exams going on<br>\nnow that I am done with the exams<br>\nwhat were the plans for this part <span class=\"user-mention\" data-user-id=\"102902\">@Sean</span> ?</p>",
        "id": 235559156,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619029808
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247135\">@Sumagna Das</span> how'd the exams go?</p>",
        "id": 235563319,
        "sender_full_name": "Sean",
        "timestamp": 1619031621
    },
    {
        "content": "<p>no worries, good to focus on your exams.... they're kind of important ;)</p>",
        "id": 235563401,
        "sender_full_name": "Sean",
        "timestamp": 1619031639
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235563319\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> how'd the exams go?</p>\n</blockquote>\n<p>it went pretty well</p>",
        "id": 235563472,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619031661
    },
    {
        "content": "<p>there is one thing i want to ask</p>",
        "id": 235740910,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619122512
    },
    {
        "content": "<p>should i bring back all of the <code>bu_mime_*_t</code> and keep one <code>bu_mime_t</code> namespace along with it?</p>",
        "id": 235741065,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619122575
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247135\">@Sumagna Das</span> that would probably be good for now, so an app / use case could choose to be type-limited or not.  longer term I think we could probably find a way that does it with fewer API symbols, if needed.</p>",
        "id": 235783167,
        "sender_full_name": "Sean",
        "timestamp": 1619150360
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>[  0%] Built target timestamp\n[  0%] Built target BENCHMARK_PIX_cp\nScanning dependencies of target libbu-obj\n[  0%] Built target netpbm\n[  0%] Built target 04238f4c3429a37ca335f9352ba2dc81_cp\n[  0%] Building C object src/libbu/CMakeFiles/libbu-obj.dir/crashreport.c.o\n[  0%] Built target openNURBS_headers_cp\n[  0%] Built target fix_6r_cp\n[  0%] Built target nonie_r_12_cp\n[  0%] Built target nurb_example_c_cp\n[  0%] Built target raydebug_tcl_cp\n[  0%] Building C object src/libbu/CMakeFiles/libbu-obj.dir/mime.c.o\n[  0%] Built target CL_FILES_cp\n[  0%] Built target tpkg_c_cp\n[  0%] Built target termcap_cp\n[  0%] Built target brlman_tcl_cp\n[  0%] Building C object src/libbu/CMakeFiles/libbu-obj.dir/vers.c.o\nIn file included from /home/sumagnadas/github/brlcad_git/include/bu/mime.h:27,\n                 from /home/sumagnadas/github/brlcad_git/build1/src/libbu/mime.c:21:\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:887:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_AUTO’\n  887 |     BU_MIME_APPLICATION_AUTO,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:44:5: note: previous definition of ‘BU_MIME_APPLICATION_AUTO’ was here\n   44 |     BU_MIME_APPLICATION_AUTO,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:888:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_ANDREW_DASH_INSET’\n  888 |     BU_MIME_APPLICATION_ANDREW_DASH_INSET,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:45:5: note: previous definition of ‘BU_MIME_APPLICATION_ANDREW_DASH_INSET’ was here\n   45 |     BU_MIME_APPLICATION_ANDREW_DASH_INSET,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:889:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_APPLIXWARE’\n  889 |     BU_MIME_APPLICATION_APPLIXWARE,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:46:5: note: previous definition of ‘BU_MIME_APPLICATION_APPLIXWARE’ was here\n   46 |     BU_MIME_APPLICATION_APPLIXWARE,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:890:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_ATOMCAT_PLUS_XML’\n  890 |     BU_MIME_APPLICATION_ATOMCAT_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:47:5: note: previous definition of ‘BU_MIME_APPLICATION_ATOMCAT_PLUS_XML’ was here\n   47 |     BU_MIME_APPLICATION_ATOMCAT_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:891:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_ATOMSVC_PLUS_XML’\n  891 |     BU_MIME_APPLICATION_ATOMSVC_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:48:5: note: previous definition of ‘BU_MIME_APPLICATION_ATOMSVC_PLUS_XML’ was here\n   48 |     BU_MIME_APPLICATION_ATOMSVC_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:892:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_ATOM_PLUS_XML’\n  892 |     BU_MIME_APPLICATION_ATOM_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:49:5: note: previous definition of ‘BU_MIME_APPLICATION_ATOM_PLUS_XML’ was here\n   49 |     BU_MIME_APPLICATION_ATOM_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:893:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_CCXML_PLUS_XML’\n  893 |     BU_MIME_APPLICATION_CCXML_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:50:5: note: previous definition of ‘BU_MIME_APPLICATION_CCXML_PLUS_XML’ was here\n   50 |     BU_MIME_APPLICATION_CCXML_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:894:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_CDMI_DASH_CAPABILITY’\n  894 |     BU_MIME_APPLICATION_CDMI_DASH_CAPABILITY,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:51:5: note: previous definition of ‘BU_MIME_APPLICATION_CDMI_DASH_CAPABILITY’ was here\n   51 |     BU_MIME_APPLICATION_CDMI_DASH_CAPABILITY,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:895:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_CDMI_DASH_CONTAINER’\n  895 |     BU_MIME_APPLICATION_CDMI_DASH_CONTAINER,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:52:5: note: previous definition of ‘BU_MIME_APPLICATION_CDMI_DASH_CONTAINER’ was here\n   52 |     BU_MIME_APPLICATION_CDMI_DASH_CONTAINER,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:896:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_CDMI_DASH_DOMAIN’\n  896 |     BU_MIME_APPLICATION_CDMI_DASH_DOMAIN,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:53:5: note: previous definition of ‘BU_MIME_APPLICATION_CDMI_DASH_DOMAIN’ was here\n   53 |     BU_MIME_APPLICATION_CDMI_DASH_DOMAIN,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:897:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_CDMI_DASH_OBJECT’\n  897 |     BU_MIME_APPLICATION_CDMI_DASH_OBJECT,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:54:5: note: previous definition of ‘BU_MIME_APPLICATION_CDMI_DASH_OBJECT’ was here\n   54 |     BU_MIME_APPLICATION_CDMI_DASH_OBJECT,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:898:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_CDMI_DASH_QUEUE’\n  898 |     BU_MIME_APPLICATION_CDMI_DASH_QUEUE,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:55:5: note: previous definition of ‘BU_MIME_APPLICATION_CDMI_DASH_QUEUE’ was here\n   55 |     BU_MIME_APPLICATION_CDMI_DASH_QUEUE,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:899:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_CU_DASH_SEEME’\n  899 |     BU_MIME_APPLICATION_CU_DASH_SEEME,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:56:5: note: previous definition of ‘BU_MIME_APPLICATION_CU_DASH_SEEME’ was here\n   56 |     BU_MIME_APPLICATION_CU_DASH_SEEME,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:900:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_DAVMOUNT_PLUS_XML’\n  900 |     BU_MIME_APPLICATION_DAVMOUNT_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:57:5: note: previous definition of ‘BU_MIME_APPLICATION_DAVMOUNT_PLUS_XML’ was here\n   57 |     BU_MIME_APPLICATION_DAVMOUNT_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:901:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_DOCBOOK_PLUS_XML’\n  901 |     BU_MIME_APPLICATION_DOCBOOK_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:58:5: note: previous definition of ‘BU_MIME_APPLICATION_DOCBOOK_PLUS_XML’ was here\n   58 |     BU_MIME_APPLICATION_DOCBOOK_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:902:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_DSSC_PLUS_DER’\n  902 |     BU_MIME_APPLICATION_DSSC_PLUS_DER,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:59:5: note: previous definition of ‘BU_MIME_APPLICATION_DSSC_PLUS_DER’ was here\n   59 |     BU_MIME_APPLICATION_DSSC_PLUS_DER,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:903:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_DSSC_PLUS_XML’\n  903 |     BU_MIME_APPLICATION_DSSC_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:60:5: note: previous definition of ‘BU_MIME_APPLICATION_DSSC_PLUS_XML’ was here\n   60 |     BU_MIME_APPLICATION_DSSC_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:904:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_ECMASCRIPT’\n  904 |     BU_MIME_APPLICATION_ECMASCRIPT,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:61:5: note: previous definition of ‘BU_MIME_APPLICATION_ECMASCRIPT’ was here\n   61 |     BU_MIME_APPLICATION_ECMASCRIPT,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/home/sumagnadas/github/brlcad_git/build1/include/bu/mime_types.h:905:5: error: redeclaration of enumerator ‘BU_MIME_APPLICATION_EMMA_PLUS_XML’\n  905 |     BU_MIME_APPLICATION_EMMA_PLUS_XML,\n      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n.....\n</code></pre></div>\n<p>i knew something like this would happen</p>",
        "id": 235801595,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619164430
    },
    {
        "content": "<p>any suggestion how to overcome this?</p>",
        "id": 235801651,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619164453
    },
    {
        "content": "<p>You've got multiple definitions in the generated output looks like...  I'd pick one, check where it's getting defined, and trace that back to see where it's coming from in the generated logic.</p>",
        "id": 235816305,
        "sender_full_name": "starseeker",
        "timestamp": 1619172539
    },
    {
        "content": "<p>A thought - what if we completely eliminate any notion of mime type typedefs, and instead make it all integer defines.  The categories would become:</p>\n<div class=\"codehilite\"><pre><span></span><code>#define BU_MIME_UNKNOWN 0\n#define BU_MIME_APPLICATION 1\n#define BU_MIME_AUDIO 2\n...\n</code></pre></div>\n<p>and the mime types would be one long list of defines:</p>\n<div class=\"codehilite\"><pre><span></span><code>#define BU_MIME_APPLICATION_ANDREW_DASH_INSET 1\n#define BU_MIME_APPLICATION_APPLIXWARE 2\n....\n</code></pre></div>\n<p>Then we define zero terminated static  integer arrays or something similar to encode the context information:</p>\n<div class=\"codehilite\"><pre><span></span><code>static long BU_MIME_IMAGES[] = {\nBU_MIME_IMAGE_PNG,\nBU_MIME_IMAGE_JPG,\n...\n0\n};\n</code></pre></div>\n<p>and a function <code>long bu_mime_context( long mime_id)</code> to walk the arrays and find the right context.</p>\n<p>The only other functions we would need should be translators to/from strings, which we're already generating now.</p>\n<p>This both eliminates the separate typedefs for each context, and allows us to assert categories in user code if we so desire.</p>",
        "id": 235818589,
        "sender_full_name": "starseeker",
        "timestamp": 1619173836
    },
    {
        "content": "<p>Then, on the gcv side, we change the plugin setup slightly.  </p>\n<p>On the GCV library side, we define a series of bit flag types that correspond to various geometry object output categories:</p>\n<div class=\"codehilite\"><pre><span></span><code>#define BINARY_OBJ 0x01\n#define IMAGE_OBJ   0x02\n#define  GEOM_OBJ  0x04\n...\n</code></pre></div>\n<p>We have each plugin provide a function which takes two integers - a mime context and a mime type and returns an integer holding bit flags set to correspond to what that plugin can either write or create given that input.</p>\n<p>The mime context argument could be set to either BU_MIME_UNKNOWN - in which case a plugin will decide on its own if it can handle a PNG image as image data, terrain (geometry) data, or both.  If it can do both, it sets both bit flags in the return.  If the caller does provide it a mime context (BU_MIME_MODEL, say) then it will only return - if it can do it- the GEOM_OBJ flag set.</p>\n<p>Then, for a given pairing of inputs and outputs, we have a way forward.  By default, if the user doesn't constrain the solution set, gcv will make a stab at determining the file mime type but will pass BU_MIME_UNKNOWN to the reader/writer plugins to get the full range of options.  It will then look at the mime types returned from all the plugins and identify viable pairings.  If either or both of the plugin and mime context interpretations are not unique, it will report the available options back to the user and request specification of either or all of a mime context interpretation, desired output object category, and reader/writer plugin to use.  If, however, only one unique interpretation is found, then it doesn't have to ask anything and will try the only thing it can.</p>\n<p>This allows conversion problems with unique potential solutions (3dm-g, for example) to simply proceed.  Ambiguous cases (multiple plugins supporting STL or interpreting PNG as either terrain or an image object) will report the available options and give the user guidance on how to refine the problem.</p>",
        "id": 235819841,
        "sender_full_name": "starseeker",
        "timestamp": 1619174592
    },
    {
        "content": "<p>Theoretically, icv and gcv might collapse completely into just gcv...</p>",
        "id": 235819987,
        "sender_full_name": "starseeker",
        "timestamp": 1619174696
    },
    {
        "content": "<p>We may also want to add a .gcv defaults file where users can set plugin or interpretation defaults so they can avoid specifying things all the time (command line options would override the defaults file, but the defaults file could make things more automatic for \"normal\" use.)</p>",
        "id": 235821191,
        "sender_full_name": "starseeker",
        "timestamp": 1619175452
    },
    {
        "content": "<p>the define method sounds good<br>\nwe can work with that</p>",
        "id": 235829961,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619180199
    },
    {
        "content": "<p>it doesnt require any redefining of symbols/enums</p>",
        "id": 235830221,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619180294
    },
    {
        "content": "<p>the one thing i am havin problems understanding is the GCV part.</p>",
        "id": 235830327,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619180344
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235830327\">said</a>:</p>\n<blockquote>\n<p>the one thing i am havin problems understanding is the GCV part.</p>\n</blockquote>\n<p>so in the plugin file, there is a define part?<br>\nor is it on the api part?</p>",
        "id": 235830564,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619180436
    },
    {
        "content": "<p>plus the part about how we are going to name the inputs and outputs for the plugins.</p>",
        "id": 235830885,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619180572
    },
    {
        "content": "<p>The GCV plugins provide hooks to the main gcv library.  Right now (for example) there's a \"rhino_can_read\" function which takes the file and tests it.  What we can try instead is a function that accepts the mime arguments in addition to the file - this allows the plugin to have more context when making its decisions about what it can/can't read.</p>",
        "id": 235830940,
        "sender_full_name": "starseeker",
        "timestamp": 1619180601
    },
    {
        "content": "<p>If, for example, the 3DM mime type was passed in and the context passed in was BU_MIME_MODEL, the rhino_can_read function would know to try the file and see if it can open it.  However, if the context passed in was BU_MIME_IMAGE (i.e. the specific conversion path of interest is to treat the 3DM data as an image format) then rhino_can_read would report that it can't read the file.  It only supports reading the 3DM format as geometry, not as an image.</p>",
        "id": 235831161,
        "sender_full_name": "starseeker",
        "timestamp": 1619180714
    },
    {
        "content": "<p>So the function would look something like:</p>\n<div class=\"codehilite\"><pre><span></span><code>static long\n  rhino_can_read(long mime_context, long mime_type, const char *source_path)\n  {\n     if (mime_type != BU_MIME_MODEL_VND_RHINO)\n         return 0;\n\n     if (mime_context != BU_MIME_MODEL)\n         return 0;\n\n      int fv;\n      ON_String mSC;\n      ON_3dmProperties mprop;\n      if (!source_path) return 0;\n      FILE *fp = ON::OpenFile(source_path,&quot;rb&quot;);\n      if (!fp) return 0;\n      ON_BinaryFile file(ON::on_read3dm,fp);\n      if (!file.Read3dmStartSection(&amp;fv, mSC)) return 0;\n      if (!file.Read3dmProperties(mprop)) return 0;\n      return GEOM_OBJ;\n  }\n</code></pre></div>",
        "id": 235831463,
        "sender_full_name": "starseeker",
        "timestamp": 1619180876
    },
    {
        "content": "<p>This gets at addressing the issue that was causing me mental indigestion earlier - how to deal with the situation where a tiff image might need to come into a .g as a terrain import or an image.  Even a generic GEOM_OBJ return type might not be enough - we may need to encode certain supported BRL-CAD entity types as flags.  An image, for example, could be a source for dsp terrain primitives or also for an extruded bitmap...</p>",
        "id": 235831903,
        "sender_full_name": "starseeker",
        "timestamp": 1619181107
    },
    {
        "content": "<p>But as a next step we can probably just see if that approach will work - if it does, more specificity just means defining additional contexts beyond BU_MIME_MODEL and BU_MIME_IMAGE for plugins to check for.</p>",
        "id": 235832787,
        "sender_full_name": "starseeker",
        "timestamp": 1619181505
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235818589\">said</a>:</p>\n<blockquote>\n<p>A thought - what if we completely eliminate any notion of mime type typedefs, and instead make it all integer defines.  The categories would become:</p>\n<div class=\"codehilite\"><pre><span></span><code>#define BU_MIME_UNKNOWN 0\n#define BU_MIME_APPLICATION 1\n#define BU_MIME_AUDIO 2\n...\n</code></pre></div>\n<p>and the mime types would be one long list of defines:</p>\n<div class=\"codehilite\"><pre><span></span><code>#define BU_MIME_APPLICATION_ANDREW_DASH_INSET 1\n#define BU_MIME_APPLICATION_APPLIXWARE 2\n....\n</code></pre></div>\n<p>Then we define zero terminated static  integer arrays or something similar to encode the context information:</p>\n<div class=\"codehilite\"><pre><span></span><code>static long BU_MIME_IMAGES[] = {\nBU_MIME_IMAGE_PNG,\nBU_MIME_IMAGE_JPG,\n...\n0\n};\n</code></pre></div>\n<p>and a function <code>long bu_mime_context( long mime_id)</code> to walk the arrays and find the right context.</p>\n<p>The only other functions we would need should be translators to/from strings, which we're already generating now.</p>\n<p>This both eliminates the separate typedefs for each context, and allows us to assert categories in user code if we so desire.</p>\n</blockquote>\n<p>done the first two define parts</p>",
        "id": 235903589,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619209585
    },
    {
        "content": "<p>now the left of the tasks are </p>\n<ul>\n<li>making the arrays</li>\n<li>changing the codebase to accomodate the changes</li>\n</ul>",
        "id": 235903692,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619209659
    },
    {
        "content": "<p>also<br>\nshould i make the arrays in the mime_types.h file?</p>",
        "id": 235903922,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619209785
    },
    {
        "content": "<p>or somewhere other would be much better?</p>",
        "id": 235903943,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619209796
    },
    {
        "content": "<p>whatever you think makes sense - could be inside the generated bu_mime_context funtion</p>",
        "id": 235905570,
        "sender_full_name": "starseeker",
        "timestamp": 1619210589
    },
    {
        "content": "<p>ohk<br>\nso what would the function do exactly?</p>",
        "id": 235905683,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619210645
    },
    {
        "content": "<p>So given an input, it would check a series of arrays to see which one (if any) contain that integer</p>",
        "id": 235905755,
        "sender_full_name": "starseeker",
        "timestamp": 1619210696
    },
    {
        "content": "<p>get an mime type id/value, walk all the arrays, find the right type<br>\nif available, return a string that will say which context it belongs to else BU_mime_unknown?</p>",
        "id": 235905824,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619210728
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235905824\">said</a>:</p>\n<blockquote>\n<p>get an mime type id/value, walk all the arrays, find the right type<br>\nif available, return a string that will say which context it belongs to else BU_mime_unknown?</p>\n</blockquote>\n<p>is this roughly the way it will work?</p>",
        "id": 235905854,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619210743
    },
    {
        "content": "<p>Roughly, yes - I'd return the mime integer, rather than a string - we can define a function to translate mime contexts to strings if we want that (user messages, etc.), but the integer itself is probably enough for most uses.</p>",
        "id": 235906002,
        "sender_full_name": "starseeker",
        "timestamp": 1619210804
    },
    {
        "content": "<p>My first cut at it would be to generate the per-mime-context arrays, then generate a NULL terminated array of pointers to those arrays.</p>",
        "id": 235906095,
        "sender_full_name": "starseeker",
        "timestamp": 1619210850
    },
    {
        "content": "<p>Then you iterate over the array-of-arrays, and iterate over each array's contents.</p>",
        "id": 235906223,
        "sender_full_name": "starseeker",
        "timestamp": 1619210896
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235906002\">said</a>:</p>\n<blockquote>\n<p>Roughly, yes - I'd return the mime integer, rather than a string - we can define a function to translate mime contexts to strings if we want that (user messages, etc.), but the integer itself is probably enough for most uses.</p>\n</blockquote>\n<p>a function which returns a string would be handy for the message as you said</p>",
        "id": 235906224,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619210897
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235906223\">said</a>:</p>\n<blockquote>\n<p>Then you iterate over the array-of-arrays, and iterate over each array's contents.</p>\n</blockquote>\n<p>that sounds better</p>",
        "id": 235906271,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619210924
    },
    {
        "content": "<p>I would just make a <code>const char *bu_mime_context_str(long ctx) </code> function</p>",
        "id": 235906289,
        "sender_full_name": "starseeker",
        "timestamp": 1619210935
    },
    {
        "content": "<p>currently i am trying to atleast get the part for arrays working<br>\nthen make the array of pointers if it helps</p>",
        "id": 235906373,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619210991
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235906289\">said</a>:</p>\n<blockquote>\n<p>I would just make a <code>const char *bu_mime_context_str(long ctx) </code> function</p>\n</blockquote>\n<p>that i will keep for the endgame</p>",
        "id": 235906442,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211010
    },
    {
        "content": "<p>the main part is the one which returns the integer</p>",
        "id": 235906469,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211027
    },
    {
        "content": "<p>However you want to approach it.  <span class=\"user-mention\" data-user-id=\"102902\">@Sean</span> hasn't weighed in, and he may have other thoughts</p>",
        "id": 235906498,
        "sender_full_name": "starseeker",
        "timestamp": 1619211043
    },
    {
        "content": "<p>thats the problem right now</p>",
        "id": 235906530,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211068
    },
    {
        "content": "<p>You mean the big one to return the integer?  Yes, that's the main logic.</p>",
        "id": 235906563,
        "sender_full_name": "starseeker",
        "timestamp": 1619211087
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235906563\">said</a>:</p>\n<blockquote>\n<p>You mean the big one to return the integer?  Yes, that's the main logic.</p>\n</blockquote>\n<p>yea</p>",
        "id": 235906584,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211102
    },
    {
        "content": "<div class=\"codehilite\"><pre><span></span><code>foreach(context ${ACTIVE_TYPES})\n  string(TOUPPER &quot;${context}&quot; c)\n  set(mcstr &quot;${mcstr}             if (mime_${context}(ext) != -1){\\n&quot;)\n  set(mcstr &quot;${mcstr}                  return mime_${context}(ext);\\n&quot;)\n  set(mcstr &quot;${mcstr}             }\\n&quot;)\nendforeach(context ${ACTIVE_TYPES})\n</code></pre></div>\n<p>i had this part before to iterate between all of the mime types</p>",
        "id": 235906787,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211218
    },
    {
        "content": "<p>do you think i could reuse this logic for this one in \"the\" function?</p>",
        "id": 235906835,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211242
    },
    {
        "content": "<p>you'll have to experiment - it'll most likely take a few iterations to arrive at a final design.</p>",
        "id": 235906914,
        "sender_full_name": "starseeker",
        "timestamp": 1619211273
    },
    {
        "content": "<p>will try to setup atleast the array part right now</p>",
        "id": 235906995,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211317
    },
    {
        "content": "<p>then move on to the function</p>",
        "id": 235907010,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211324
    },
    {
        "content": "<p>the function is nothing without the arrays</p>",
        "id": 235907021,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211332
    },
    {
        "content": "<p>but right now thinking whether it is better to put it with the mime_types.h file or in the mime.c file</p>",
        "id": 235907108,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211367
    },
    {
        "content": "<p>which one sounds better for keeping the array for the defines?</p>",
        "id": 235907145,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211386
    },
    {
        "content": "<p>If it were me I'd probably define the arrays as part of the function.</p>",
        "id": 235907202,
        "sender_full_name": "starseeker",
        "timestamp": 1619211428
    },
    {
        "content": "<p>ok</p>",
        "id": 235907217,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211444
    },
    {
        "content": "<p>lemme try then</p>",
        "id": 235907244,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211459
    },
    {
        "content": "<p>vs code just crashed out of nowhere <span aria-label=\"neutral\" class=\"emoji emoji-1f610\" role=\"img\" title=\"neutral\">:neutral:</span></p>",
        "id": 235907338,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211499
    },
    {
        "content": "<p>in the current mime.c I generated all the string to number and back mappings as static if checks, IIRC...</p>",
        "id": 235907345,
        "sender_full_name": "starseeker",
        "timestamp": 1619211501
    },
    {
        "content": "<p>You might give Ninja on windows a try... less overhead</p>",
        "id": 235907381,
        "sender_full_name": "starseeker",
        "timestamp": 1619211529
    },
    {
        "content": "<p>It should work - that's what our CI on github is using.</p>",
        "id": 235907394,
        "sender_full_name": "starseeker",
        "timestamp": 1619211541
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235907345\">said</a>:</p>\n<blockquote>\n<p>in the current mime.c I generated all the string to number and back mappings as static if checks, IIRC...</p>\n</blockquote>\n<p>yea<br>\nall the functions are present in the mime.c file</p>",
        "id": 235907411,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211556
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235907381\">said</a>:</p>\n<blockquote>\n<p>You might give Ninja on windows a try... less overhead</p>\n</blockquote>\n<p>is ninja available in linux?</p>",
        "id": 235907430,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211573
    },
    {
        "content": "<p>Oh, sorry - I thought you meant visual studio.  yes, ninja is primarily used on Linux</p>",
        "id": 235907478,
        "sender_full_name": "starseeker",
        "timestamp": 1619211600
    },
    {
        "content": "<p>That won't help you though if you're using vs code as your source editor</p>",
        "id": 235907633,
        "sender_full_name": "starseeker",
        "timestamp": 1619211620
    },
    {
        "content": "<p>let me check though</p>",
        "id": 235907749,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211642
    },
    {
        "content": "<p>i use the terminal inside VS code for building most of the time as i use a different build folder for this change or else normal building gets messed up</p>",
        "id": 235907843,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211659
    },
    {
        "content": "<p>/me uses vim most of the time, and Emacs when he must (DocBook editing usually).</p>",
        "id": 235907937,
        "sender_full_name": "starseeker",
        "timestamp": 1619211678
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235907937\">said</a>:</p>\n<blockquote>\n<p>/me uses vim most of the time, and Emacs when he must (DocBook editing usually).</p>\n</blockquote>\n<p>i heard that vim is a good one but havent tried yet because no time for learning new things <span aria-label=\"sweat\" class=\"emoji emoji-1f613\" role=\"img\" title=\"sweat\">:sweat:</span></p>",
        "id": 235908286,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211746
    },
    {
        "content": "<p>have my 10th grade's exam coming next year</p>",
        "id": 235908596,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619211818
    },
    {
        "content": "<p>and one last thing.....should there be an auto and an unknown special for every category like \"BU_MIME_IMAGE_AUTO\", \"BU_MIME_IMAGE_UNKNOWN\" in every array?</p>",
        "id": 235913740,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619214105
    },
    {
        "content": "<p>right now, the arrays part is ready without those special ones including the array of arrays<br>\nnow the only part that is left is the real logic which returns the integer for the right context/category</p>",
        "id": 235914174,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619214348
    },
    {
        "content": "<p>Not sure about the unknowns - my thought right now is one generic unknown mime type is probably enough, unless we think of a use case.</p>",
        "id": 235915483,
        "sender_full_name": "starseeker",
        "timestamp": 1619215200
    },
    {
        "content": "<p>ohk</p>",
        "id": 235942141,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619240401
    },
    {
        "content": "<p>right now, the only thing i am having a problem is that i can iterate thru the array of arrays but when it comes to the array containing the types, i have no such variable in the cmake file which can help me get the number of elements in each array</p>",
        "id": 235942358,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619240572
    },
    {
        "content": "<p>so do you know of any condition which can help me get each of the elements in the array</p>",
        "id": 235942411,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619240640
    },
    {
        "content": "<p>like for using while?</p>",
        "id": 235942452,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619240650
    },
    {
        "content": "<p>I'm not 100% sure I follow, but you can build a counter in CMake if you need to so you can write out that information.  I think it's the math() command...</p>",
        "id": 235969433,
        "sender_full_name": "starseeker",
        "timestamp": 1619270079
    },
    {
        "content": "<p>would it be worth it for each array tho?</p>",
        "id": 235969669,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619270346
    },
    {
        "content": "<p>i thought that it might make it take more memory while generating the file <span aria-label=\"shrug\" class=\"emoji emoji-1f937\" role=\"img\" title=\"shrug\">:shrug:</span></p>",
        "id": 235969738,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619270411
    },
    {
        "content": "<p>right now, i just came with an idea. as the last element  of the arrays will always be 0, we can put a while loop for *elem !=0.</p>",
        "id": 235969896,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619270561
    },
    {
        "content": "<p>how does that sound?</p>",
        "id": 235969900,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619270568
    },
    {
        "content": "<p>Sounds good.</p>",
        "id": 235970431,
        "sender_full_name": "starseeker",
        "timestamp": 1619271144
    },
    {
        "content": "<p>any idea how or where we can make an use of it?</p>",
        "id": 236002388,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619295722
    },
    {
        "content": "<p>the function is implemented</p>",
        "id": 236002436,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619295736
    },
    {
        "content": "<p>And also<br>\nIn how many places we have to change the logic of a function to work with this define logic?</p>",
        "id": 236005287,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619297941
    },
    {
        "content": "<p>Except for the mime.c file</p>",
        "id": 236005792,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619298094
    },
    {
        "content": "<p>You could try reworking a gcv plugin and the library to use the new setup, maybe starting with the 3dm (rhino) convertor and disabling the others.</p>",
        "id": 236024791,
        "sender_full_name": "starseeker",
        "timestamp": 1619312718
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235819841\">said</a>:</p>\n<blockquote>\n<p>Then, on the gcv side, we change the plugin setup slightly.  </p>\n<p>On the GCV library side, we define a series of bit flag types that correspond to various geometry object output categories:</p>\n<div class=\"codehilite\"><pre><span></span><code>#define BINARY_OBJ 0x01\n#define IMAGE_OBJ   0x02\n#define  GEOM_OBJ  0x04\n...\n</code></pre></div>\n<p>We have each plugin provide a function which takes two integers - a mime context and a mime type and returns an integer holding bit flags set to correspond to what that plugin can either write or create given that input.</p>\n<p>The mime context argument could be set to either BU_MIME_UNKNOWN - in which case a plugin will decide on its own if it can handle a PNG image as image data, terrain (geometry) data, or both.  If it can do both, it sets both bit flags in the return.  If the caller does provide it a mime context (BU_MIME_MODEL, say) then it will only return - if it can do it- the GEOM_OBJ flag set.</p>\n<p>Then, for a given pairing of inputs and outputs, we have a way forward.  By default, if the user doesn't constrain the solution set, gcv will make a stab at determining the file mime type but will pass BU_MIME_UNKNOWN to the reader/writer plugins to get the full range of options.  It will then look at the mime types returned from all the plugins and identify viable pairings.  If either or both of the plugin and mime context interpretations are not unique, it will report the available options back to the user and request specification of either or all of a mime context interpretation, desired output object category, and reader/writer plugin to use.  If, however, only one unique interpretation is found, then it doesn't have to ask anything and will try the only thing it can.</p>\n<p>This allows conversion problems with unique potential solutions (3dm-g, for example) to simply proceed.  Ambiguous cases (multiple plugins supporting STL or interpreting PNG as either terrain or an image object) will report the available options and give the user guidance on how to refine the problem.</p>\n</blockquote>\n<p>this was one of the things you wanted with the gcv library?</p>",
        "id": 236089644,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619381053
    },
    {
        "content": "<p>if i follow this, there are some questions in my mind</p>\n<ul>\n<li>how many flags do we need to define?</li>\n<li>how are we going to handle the flags?</li>\n</ul>",
        "id": 236089909,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619381348
    },
    {
        "content": "<p>one other question, how do i return both bit flags?</p>",
        "id": 236094541,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619385468
    },
    {
        "content": "<p>There are tutorials online about bit flags and bit masks - see, for example, <a href=\"https://www.learn-c.org/en/Bitmasks\">https://www.learn-c.org/en/Bitmasks</a></p>",
        "id": 236096697,
        "sender_full_name": "starseeker",
        "timestamp": 1619387802
    },
    {
        "content": "<p><a href=\"https://www.codeproject.com/Articles/2247/An-introduction-to-bitwise-operators\">https://www.codeproject.com/Articles/2247/An-introduction-to-bitwise-operators</a></p>",
        "id": 236096742,
        "sender_full_name": "starseeker",
        "timestamp": 1619387872
    },
    {
        "content": "<p>Basically the idea is you return a single number, and the on/off status of the individual bits is used to contain information.</p>",
        "id": 236096812,
        "sender_full_name": "starseeker",
        "timestamp": 1619387922
    },
    {
        "content": "<p>I tend to go with an unsigned long long to maximize the potential number of flags that can be set in a single number.</p>",
        "id": 236096839,
        "sender_full_name": "starseeker",
        "timestamp": 1619387973
    },
    {
        "content": "<p>As to how many flags we will need to define, that's one of the things that isn't fully clear yet.</p>",
        "id": 236096851,
        "sender_full_name": "starseeker",
        "timestamp": 1619387997
    },
    {
        "content": "<p>They'll be handled (set and checked) as bit masks (there are other examples in our code where we use such flags)</p>",
        "id": 236096966,
        "sender_full_name": "starseeker",
        "timestamp": 1619388058
    },
    {
        "content": "<p>So we return a single number, but the bit flags are used to encode multiple pieces of information within the single number.</p>",
        "id": 236097000,
        "sender_full_name": "starseeker",
        "timestamp": 1619388098
    },
    {
        "content": "<p>An unsigned long long will be (at least) 64 bits, so that gives us up to 64 flags within that single number.</p>",
        "id": 236097129,
        "sender_full_name": "starseeker",
        "timestamp": 1619388191
    },
    {
        "content": "<p>I would suggest making a small C or C++ program and exploring how those flags work, if you're unfamiliar with them.</p>",
        "id": 236097244,
        "sender_full_name": "starseeker",
        "timestamp": 1619388276
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/236097244\">said</a>:</p>\n<blockquote>\n<p>I would suggest making a small C or C++ program and exploring how those flags work, if you're unfamiliar with them.</p>\n</blockquote>\n<p>it looks like i will have to do this to understand it</p>",
        "id": 236133879,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619423746
    },
    {
        "content": "<p>its a bit mind boggling</p>",
        "id": 236133960,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619423777
    },
    {
        "content": "<p>I'm late to the party, but I'd question the value of bitsets for typedefs, and they're fundamentally limited to the number of available bits.  It'd have to go over 64 bits if we're talking the types themselves (or is this only for categories?), and solutions for that are typically obnoxious...</p>",
        "id": 236281556,
        "sender_full_name": "Sean",
        "timestamp": 1619497313
    },
    {
        "content": "<p>The usual reason for doing bit flags is for performance, which really isn't needed here.  This whole system is primarily dealing with file identification, in I/O land (i.e., as slow as it gets).  If the direction is to get a handle to an identifier, then we might as well directly adopt the mime-type classifier string-as-data and ditch all the API complexity.</p>",
        "id": 236281756,
        "sender_full_name": "Sean",
        "timestamp": 1619497544
    },
    {
        "content": "<p>That would greatly simplify things.</p>",
        "id": 236281762,
        "sender_full_name": "Sean",
        "timestamp": 1619497552
    },
    {
        "content": "<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>Apps/Libs could set \"*\" (i.e., mime unknown) or \"model\\*\" (i.e., mime category 'model') etc.\nPlugins could declare categories or specific types or sets of types (e.g., \"model/*\" and/or \"text/plain\").\n</code></pre></div>",
        "id": 236281870,
        "sender_full_name": "Sean",
        "timestamp": 1619497674
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235942358\">said</a>:</p>\n<blockquote>\n<p>right now, the only thing i am having a problem is that i can iterate thru the array of arrays but when it comes to the array containing the types, i have no such variable in the cmake file which can help me get the number of elements in each array</p>\n</blockquote>\n<p>If you've created a fixed array at compile time, then you can determine the size with:<br>\nsize_t length = sizeof(array) / sizeof(array[0]);</p>",
        "id": 236282005,
        "sender_full_name": "Sean",
        "timestamp": 1619497817
    },
    {
        "content": "<p>If I got that correctly, The bit flags are only for the categories and not for all the types.</p>",
        "id": 236292076,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619506927
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/236282005\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/235942358\">said</a>:</p>\n<blockquote>\n<p>right now, the only thing i am having a problem is that i can iterate thru the array of arrays but when it comes to the array containing the types, i have no such variable in the cmake file which can help me get the number of elements in each array</p>\n</blockquote>\n<p>If you've created a fixed array at compile time, then you can determine the size with:<br>\nsize_t length = sizeof(array) / sizeof(array[0]);</p>\n</blockquote>\n<p>yea got this part working......</p>",
        "id": 236390966,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619550103
    },
    {
        "content": "<p>one thing i have to ask, should i work using the bit flags?</p>",
        "id": 236399881,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619553987
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/236399881\">said</a>:</p>\n<blockquote>\n<p>one thing i have to ask, should i work using the bit flags?</p>\n</blockquote>\n<p><span class=\"user-mention\" data-user-id=\"102902\">@Sean</span></p>",
        "id": 236399918,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619554007
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"112516\">@starseeker</span>  got the functions working with the extra arguments but how to use the returned bit flag tho?</p>",
        "id": 236572841,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619641672
    },
    {
        "content": "<p>right now, testing the syntax atleast thru the 3DM plugin. the other plugins are disabled for now.</p>",
        "id": 236573056,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619641769
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/236572841\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span>  got the functions working with the extra arguments but how to use the returned bit flag tho?</p>\n</blockquote>\n<p>like what should i do with bit flags?<br>\nshould i check for the output types?<br>\nshould i send them to the user through a selection menu?</p>",
        "id": 236573331,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619641880
    },
    {
        "content": "<p>So my thinking, for what it's worth, was to do the following:</p>\n<p>Have the gcv executable support an option to specify the processing mode:  --image for example to treat a .tiff file as an image, and --geom to force processing as geometry.</p>\n<p>What should happen if you feed gcv the .3dm file and tell it to process it as an image, would be for it to query the plugin with the mime context set to BU_MIME_IMAGE.  The plugin, in turn, should recognize that it can't process a 3dm file as an image, and return nothing.</p>\n<p>With the --geom option set, the context would be set to BU_MIME_MODEL, and without it the context would be BU_MIME_UNKNOWN.  In either of those cases the plugin would then report it could handle the 3dm input successfully, and return a value with the GEOM bit flag set.  The gcv executable would then know it had at least one conversion path.</p>\n<p>This gets more interesting with an image format like .png.  Since it could be interpreted as either an image or terrain data, if we don't supply either --image or --geom to introduce a context both a plugin to read pngs and generate .g files containing those images and the gdal plugin producing geometry files will report they can handle the PNG file.  If --image or --geom are supplied, and the prospective plugins return values with their respective bit flags set, gcv can select the plugin that not only handles PNG but handles it as the desired type of information.  If neither --image or --geom are supplied and the PNG file is fed to gcv, we don't know what to do with it - there are multiple valid options.  In that case gcv can use the return codes from the plugin tests to report the available options.  Something like:</p>\n<div class=\"codehilite\"><pre><span></span><code>gcv terrain.png outfile.g\n\nError - multiple conversion alternatives found:\n\nImage conversions (--image):\n     png2gtexture  - Import PNG image as BRL-CAD texture file\n\nGeometry conversions (--geom):\n    gdal            - Import PNG image as DSP terrain data\n</code></pre></div>\n<p>To actually get the gdal conversion path in this scenario, the command would be either:</p>\n<div class=\"codehilite\"><pre><span></span><code>gdal --geom terrain.png outfile.g\n</code></pre></div>\n<p>or </p>\n<div class=\"codehilite\"><pre><span></span><code>gda --plugin=gdal terrain.png outfile.pn\n</code></pre></div>",
        "id": 236582586,
        "sender_full_name": "starseeker",
        "timestamp": 1619644881
    },
    {
        "content": "<p>If a plugin could be capable of producing either image or geometry outputs from the same input (let's say hypothetically the gdal plugin was also able to produce a texture as well as a terrain file) it would return with both the image and geom bit flags set.  In that case, even if it was the only plugin that could handle the format, gcv would know it needs additional context before the plugin can proceed to do a conversion:</p>\n<div class=\"codehilite\"><pre><span></span><code>gcv --plugin gdal terrain.png output.png\n\nError:  plugin supports both image and geometry conversion paths:\n\n   image:   produces a .g texture object\n    geom:   produces a dsp terrain file\n</code></pre></div>\n<p>The terrain path would then become:</p>\n<div class=\"codehilite\"><pre><span></span><code>gcv --plugin gdal --geom terrain.png output.png\n</code></pre></div>",
        "id": 236583675,
        "sender_full_name": "starseeker",
        "timestamp": 1619645196
    },
    {
        "content": "<p>got the options <code>--geom</code> and <code>--image</code> working somewhat. currently it just passes the <code>BU_MIME_MODEL</code> and <code>BU_MIME_IMAGE</code> defs respectively.</p>",
        "id": 236745774,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619730336
    },
    {
        "content": "<p>i just want to ask.....is the returned bit flag mainly going to be used to check if there are options for plugins for a certain file?</p>",
        "id": 236993666,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619898362
    },
    {
        "content": "<p>and i am a little bit confused right now........i tried to go for it and couldnt find out where it is checking for the types and using the function *_can_read</p>",
        "id": 237000797,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619903684
    },
    {
        "content": "<p>so it might help if someone can get me thru this confusion</p>",
        "id": 237000846,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619903705
    },
    {
        "content": "<p>My idea (which <span class=\"user-mention\" data-user-id=\"102902\">@Sean</span>  may shoot down - it's just a notion) was to use the return bit flag to determine what sorts of input/output a given importer/exporter can handle.</p>\n<p>If I'm following this correctly (it's been a while) struct gcv_filter in include/gcv/api.h has a callback function data_supported - I think that's where the can_read functions get hooked in.  To make sure, try stepping through a gcv conversion in gdb and breaking on the can_read function in question - the backtrace should tell you how it's being called.</p>",
        "id": 237005269,
        "sender_full_name": "starseeker",
        "timestamp": 1619907548
    },
    {
        "content": "<p>Here's another stab at how I envisioned this working.  Given the conversion input:</p>\n<div class=\"codehilite\"><pre><span></span><code>gcv file.png file.g\n</code></pre></div>\n<p>The initial filename based characterizations would be:</p>\n<p>mime-characterize png -&gt; BU_MIME_IMAGE, BU_MIME_IMAGE_PNG<br>\nmime-characterize g -&gt; BU_MIME_MODEL, BU_MIME_MODEL_VND_BRLCAD_G</p>\n<p>Step 1a:  ask all reader plugins if they can handle BU_MIME_UNKNOWN, BU_MIME_IMAGE_PNG and collect responses<br>\nStep 1b:  ask all writer plugins if they can handle BU_MIME_UNKNOWN, BU_MIME_MODEL_VND_BRLCAD_G and collect responses</p>\n<p>Step 2:  for any plugins that answer non-zero, characterize their responses as being BU_MIME_IMAGE, BU_MIME_MODEL, or both.  The possibilities for both readers and writers are:</p>\n<ol>\n<li>1 plugin, with BU_MIME_MODEL as its response.</li>\n<li>1 plugin, with BU_MIME_IMAGE as its response.</li>\n<li>2+ plugins, with BU_MIME_MODEL as their response.</li>\n<li>2+ plugins, non-BU_MIME_MODEL types.</li>\n<li>Multiple types from same plugin</li>\n<li>Multiple types, multiple plugins</li>\n</ol>\n<p>Step 3:  Find matching reader and writer context pairings that offer conversion paths.  For our hypothetical example where gdal can read a PNG both as image and terrain data, we would get the following valid conversion path pairings:</p>\n<p>(BU_MIME_IMAGE,gdal)-&gt;(BU_MIME_IMAGE,g)<br>\n(BU_MIME_MODEL,gdal)-&gt;(BU_MIME_MODEL,g)</p>\n<p>This situation is thus ambiguous - both the reader and writer have multiple valid interpretations of the data.  The user  will have to provide more context (for example --geom to specify our desired conversion context is BU_MIME_MODEL) to resolve the ambiguity.</p>",
        "id": 237006801,
        "sender_full_name": "starseeker",
        "timestamp": 1619909080
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/237005269\">said</a>:</p>\n<blockquote>\n<p>My idea (which <span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span>  may shoot down - it's just a notion) was to use the return bit flag to determine what sorts of input/output a given importer/exporter can handle.</p>\n<p>If I'm following this correctly (it's been a while) struct gcv_filter in include/gcv/api.h has a callback function data_supported - I think that's where the can_read functions get hooked in.  To make sure, try stepping through a gcv conversion in gdb and breaking on the can_read function in question - the backtrace should tell you how it's being called.</p>\n</blockquote>\n<p>for some reason, the <code>can_read</code> function wasnt being called when i tried putting it thru gdb. thats why i asked for where it is being called. IIRC in the code the only place where the function was called was in a condition and one of other conditions in that if statement was <code>if (emt == BU_MIME_MODEL_AUTO &amp;&amp; ......)</code> and because of that the function is not being called for some reason.</p>",
        "id": 237029038,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1619934281
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247135\">@Sumagna Das</span> you may have to alter the gcv logic flows somewhat - they've always been a bit haphazard, so if something else makes sense to you feel free to give it a go.</p>",
        "id": 237073937,
        "sender_full_name": "starseeker",
        "timestamp": 1619982342
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"247135\">@Sumagna Das</span> how's it going?  any luck deciphering the logic flow?</p>",
        "id": 237442414,
        "sender_full_name": "Sean",
        "timestamp": 1620191726
    },
    {
        "content": "<p>While I'm not convinced there's usability value in having categoric flags, I'm not terribly opposed.  More concerned where this is heading.  I think the user isn't necessarily going to know what a particular input plugin was coded to receive or what a particular filter plugin is expecting.   So they're probably going to have to hunt or try them all to see what they do and that won't be a good user experience.</p>",
        "id": 237442834,
        "sender_full_name": "Sean",
        "timestamp": 1620192183
    },
    {
        "content": "<p>There's also an issue with many formats that have even more interpretations beyond image or geometry ... could also be data, could be a container format, could be a single format that holds multiple interpretations or multiple representations simultaneously.  It's messy and categorization works against us.</p>",
        "id": 237443279,
        "sender_full_name": "Sean",
        "timestamp": 1620192688
    },
    {
        "content": "<p>As mentioned earlier, I'd think it'd be beneficial to focus on specific issues, such as getting vol plugin to simply work, and address the problems that specific case provokes.  That's not to suggest undoing or changing anything that's been done on the pull request, but to wrap it up and get back to considering how that vol plugin works now and talking about that usability.</p>\n<p>i.e., how it is discovered and how is it invoked unambiguously with a starting premise that a user begins with a naive invocation such as \"gcv input.png output.g\"</p>",
        "id": 237443774,
        "sender_full_name": "Sean",
        "timestamp": 1620193204
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/237442414\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> how's it going?  any luck deciphering the logic flow?</p>\n</blockquote>\n<p>somewhat<br>\nhavent been able to play with it in the last few days because of studies and dont think i will be able to do that in the next few days<br>\nso not much luck you can say</p>",
        "id": 237980652,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1620503881
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/237443774\">said</a>:</p>\n<blockquote>\n<p>As mentioned earlier, I'd think it'd be beneficial to focus on specific issues, such as getting vol plugin to simply work, and address the problems that specific case provokes.  That's not to suggest undoing or changing anything that's been done on the pull request, but to wrap it up and get back to considering how that vol plugin works now and talking about that usability.</p>\n<p>i.e., how it is discovered and how is it invoked unambiguously with a starting premise that a user begins with a naive invocation such as \"gcv input.png output.g\"</p>\n</blockquote>\n<p>thats actually done <br>\ni had that on sideby in a git stash so i can put all of the work right now into another stash, pop the stash which contains the vol plugin work and with some minor changes, voila! the plugin and the initial work for the GCV rework is done in the pull request.</p>",
        "id": 237980853,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1620504063
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/237442834\">said</a>:</p>\n<blockquote>\n<p>While I'm not convinced there's usability value in having categoric flags, I'm not terribly opposed.  More concerned where this is heading.  I think the user isn't necessarily going to know what a particular input plugin was coded to receive or what a particular filter plugin is expecting.   So they're probably going to have to hunt or try them all to see what they do and that won't be a good user experience.</p>\n</blockquote>\n<p>The user won't know what the plugins can do or expect - that's the idea of the proposed scheme, to have the plugins themselves tell gcv what they can and can't do, and have gcv solve the problem of what combinations constitute potentially viable conversion paths.  If the path solution is not unique, gcv then presents the viable paths and how to invoke them to the user.</p>",
        "id": 237981596,
        "sender_full_name": "starseeker",
        "timestamp": 1620504766
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/237443279\">said</a>:</p>\n<blockquote>\n<p>There's also an issue with many formats that have even more interpretations beyond image or geometry ... could also be data, could be a container format, could be a single format that holds multiple interpretations or multiple representations simultaneously.  It's messy and categorization works against us.</p>\n</blockquote>\n<p>If we've got inputs that are fundamentally that messy (not all of them are, but I'm sure some are) then I see no alternative other than analyzing them to find the viable interpretations and reporting them back to the user with instructions for how to select the interpretation they want.  That means we need some universal language in which to communicate those capabilities and options (data, image, geometry, video, etc.)  The set of categoric data possibilities must ultimately be finite in order to be implementable, and for our problems there are usually just a few big ones (image, geometry, etc.) - hence my thinking that we could use the bit flag to communicate the viable options back from a plugin.</p>",
        "id": 237981912,
        "sender_full_name": "starseeker",
        "timestamp": 1620505105
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"247135\">Sumagna Das</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/237980853\">said</a>:</p>\n<blockquote>\n<p><span class=\"user-mention silent\" data-user-id=\"102902\">Sean</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/237443774\">said</a>:</p>\n<blockquote>\n<p>As mentioned earlier, I'd think it'd be beneficial to focus on specific issues, such as getting vol plugin to simply work, and address the problems that specific case provokes.  That's not to suggest undoing or changing anything that's been done on the pull request, but to wrap it up and get back to considering how that vol plugin works now and talking about that usability.</p>\n<p>i.e., how it is discovered and how is it invoked unambiguously with a starting premise that a user begins with a naive invocation such as \"gcv input.png output.g\"</p>\n</blockquote>\n<p>thats actually done <br>\ni had that on sideby in a git stash so i can put all of the work right now into another stash, pop the stash which contains the vol plugin work and with some minor changes, voila! the plugin and the initial work for the GCV rework is done in the pull request.</p>\n</blockquote>\n<p>i had pushed the vol plugin changes alongside the changes for flattening the mime namespace. review it when you can</p>",
        "id": 238053044,
        "sender_full_name": "Sumagna Das",
        "timestamp": 1620585720
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/237981596\">said</a>:</p>\n<blockquote>\n<p>The user won't know what the plugins can do or expect - that's the idea of the proposed scheme, to have the plugins themselves tell gcv what they can and can't do, and have gcv solve the problem of what combinations constitute potentially viable conversion paths.  If the path solution is not unique, gcv then presents the viable paths and how to invoke them to the user.</p>\n</blockquote>\n<p>I agree the user won't know, but for that same reason they won't necessarily know whether -image or -data or -model or whatever taxonomy we come up with is appropriate.  It's still not unambiguous what that means if the user specifies a png file with a category flag.  It turns into \"try them all and see what they do\".  It's compounded by the fact that category flags attempt to characterize an input or/and output homogeneously which isn't necessarily true or even a common case.</p>\n<p>The resulting workflow sounds like a problematic UX to me..  So much so that I think we're better off focusing on declarative and getting that UX right first..  It's needed no matter what.  Let's keep it simple.  We really need to resist overarchitecting as simplicity will be central to any external adoption.</p>",
        "id": 238423822,
        "sender_full_name": "Sean",
        "timestamp": 1620797939
    },
    {
        "content": "<p><span class=\"user-mention silent\" data-user-id=\"112516\">starseeker</span> <a href=\"#narrow/stream/104062-general/topic/GCV/near/237981912\">said</a>:</p>\n<blockquote>\n<p>If we've got inputs that are fundamentally that messy (not all of them are, but I'm sure some are) then I see no alternative other than analyzing them to find the viable interpretations and reporting them back to the user with instructions for how to select the interpretation they want.</p>\n</blockquote>\n<p>Agreed!</p>\n<blockquote>\n<p>That means we need some universal language in which to communicate those capabilities and options (data, image, geometry, video, etc.)</p>\n</blockquote>\n<p>Sort of!  :)</p>\n<p>I think that's the leap to a particular solution implementat that I don't think is demonstrated.  The universal language couple be plain english.  If there are three plugins that can handle an input, we could simply itemize them with a description and let the user pick based on that info.  In this particular instance, the user would see something like:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>$ gcv image.png file.g\n Multiple plugins read PNG input.  Please select the one most appropriate with the --input=[label] option:\n    gdal: Reads image and data files typically representing terrain creating height field (DSP) geometry.\n    png-to-vol: Reads PNG format image files creating volumetric (VOL) geometry.\n    magick: Reads multiple image file formats.\n</code></pre></div>\n<p>So then the user can decide which seems most appropriate and issue:</p>\n<div class=\"codehilite\" data-code-language=\"Text only\"><pre><span></span><code>$ gcv --input=png-to-vol image.png file.g\n</code></pre></div>\n<p>It's simple, discoverable, and doesn't require taxonomy awareness other than what the plugins declare.  The user may still try all of them, but it'll be in the context of a plugin's immediate description and other available plugins.  We can later look into user preferences for default handlers or auto-pathing.</p>",
        "id": 238424996,
        "sender_full_name": "Sean",
        "timestamp": 1620799071
    },
    {
        "content": "<p><span class=\"user-mention\" data-user-id=\"484201\">@Christopher</span> So the next logical question I guess is what is needed to make assetimport prioritized over the other tinygltf method.  Could just remove the other method since it's crashing if the other works, or does it handle text gltf better in some regard?  Otherwise that's a design issue that needs to be sorted out - how to have smart defaulting.</p>",
        "id": 425135293,
        "sender_full_name": "Sean",
        "timestamp": 1709744387
    },
    {
        "content": "<p>well, if it's just a matter of wanting it to prioritize assetimport over tinygltf, we just need to recognize it as the default 'mime type'. As of yet, gcv isn't advanced enough have <em>smart</em> defaulting or really any notion fallbacks; Only the hard-set default, anything else is up to the user to manually specify</p>",
        "id": 425135985,
        "sender_full_name": "Christopher",
        "timestamp": 1709744594
    },
    {
        "content": "<p>as for why it's crashing or if one is preferable over the other.. I'm not sure</p>",
        "id": 425136064,
        "sender_full_name": "Christopher",
        "timestamp": 1709744625
    },
    {
        "content": "<p>I'd vote for removing tinygltf in favor of assetimport, unless there's something the former can handle that the latter can't.</p>",
        "id": 425145630,
        "sender_full_name": "starseeker",
        "timestamp": 1709747674
    },
    {
        "content": "<p>I think one of us will have to spend a few minutes looking at the implementations to figure that out.  I don't recall the one in gcv being different than the gltf-g but there's clearly some difference or change.  Looking at the commits, maybe a casualty of refactoring errors.</p>\n<p>I naively assumed gcv was only using assetimport as I'd just ran \"gcv file.glb file.g\".  Either way, I do think the default should be made to work, so if assetimport's working I think that's strong enough motivation to default to it over the gltf plugin.  Can schedule them and gltf-g for review in the next minor.  Maybe do a quick walkthrough.</p>",
        "id": 425151179,
        "sender_full_name": "Sean",
        "timestamp": 1709749523
    }
]